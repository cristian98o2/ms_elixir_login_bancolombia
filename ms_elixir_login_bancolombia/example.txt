defmodule MsElixirLoginBancolombia.Jwt.GenerateJWTAdapter do
  @moduledoc """
  Adaptador para generar y validar JSON Web Tokens (JWT).
  """
  alias Joken.Token

  @secret_string "12345678912345678912345678912345"
  @expiration_time 300

  @key Joken.Signer.create("HS256", @secret_string)

  @spec generate_token(String.t()) :: {:ok, String.t()} | {:error, any()}
  def generate_token(user_email) do
    Token.build(%{sub: user_email})
    |> Token.add_claim("exp", Joken.generate_exp(@expiration_time))
    |> Joken.sign(@key)
  end

  @spec validate_token(String.t() | nil) :: {:ok, any()} | {:error, :jwt_expired}
  def validate_token(nil), do: {:error, :jwt_expired}

  def validate_token(token) do
    case Joken.verify_and_validate(token, @key) do
      {:ok, %{claims: claims}} ->
        {:ok, claims}

      {:error, _reason} ->
        {:error, :jwt_expired}
    end
  end
end

defmodule MsElixirLoginBancolombia.Jwt.GenerateJWTAdapter do
  @moduledoc """
  Adaptador para generar y validar JSON Web Tokens (JWT).
  """
  alias MsElixirLoginBancolombia.Jwt.Token

  @expiration_time 300

  def generate_token(email) do
    now = DateTime.utc_now()
    exp = DateTime.add(now, @expiration_time, :second)

    claims = %{
      "sub" => email,
      "iat" => DateTime.to_unix(now),
      "exp" => DateTime.to_unix(exp)
    }

    {:ok, token} = Token.generate_and_sign(claims)
  end

  @spec validate_token(String.t() | nil) :: {:ok, any()} | {:error, :jwt_expired}
  def validate_token(nil), do: {:error, :jwt_expired}

  def validate_token(token) do
    case Token.verify_and_validate(token) do
      {:ok, claims} ->
        {:ok, claims}

      {:error, _reason} ->
        {:error, :jwt_expired}
    end
  end
end

defmodule MsElixirLoginBancolombia.Jwt.Token do
  use Joken.Config

  @secret "12345678912345678912345678912345"

  @impl true
  def token_config do
    default_claims(skip: [:jti])
    |> add_claim("sub", nil, &is_binary/1)
    |> with_signer(Joken.Signer.create("HS256", @secret))
  end
end